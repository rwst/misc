# -*- coding: utf-8 -*-
r"""
C-Finite Sequences

CFiniteSequences are completely
defined by and equivalent to their ordinary generating function (OGF, which
is always a polynomial fraction).

C-finite sequences satisfy homogenous linear recurrences with constant coefficients:

.. MATH::
    
    a_{n+d} = c_0a_n + c_1a_{n+1} + \cdots + c_{d-1}a_{n+d-1}, \quad d\ge0.
    
This implementation allows any Laurent polynomial fraction as OGF by interpreting
any power of x dividing the OGF numerator or denominator as a right or left shift
of the sequence offset. This also enables subclassing from FractionFieldElement
with usage of its member functions, so you can add, multiply,
partial_fraction_decomposition() etc. the C-finite sequence.

EXAMPLES::

    sage: R.<x>=ZZ[]
    sage: fibo = CFiniteSequence(x/(1-x-x^2))        # the Fibonacci sequence
    sage: fibo
    C-finite sequence, generated by x/(-x^2 - x + 1)
    sage: fibo[137]                 #the 137th term of the Fibonacci sequence
    19134702400093278081449423917
    sage: fibo[137] == fibonacci(137)
    True
    sage: fibo.seq(12)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    sage: fibo[14:4:-2]
    [377, 144, 55, 21, 8]

They can be created also from the coefficients and start values of a recurrence.
    
EXAMPLES::

    sage: r = CFiniteSequence.from_recurrence([1,1],[0,1])
    sage: r == fibo
    True

Given enough values, the ordinary generating function (ogf) of a C-finite sequence
can be guessed.
    
EXAMPLES::

    sage: r=CFiniteSequence.guess([0,1,1,2,3,5,8]);
    sage: r == fibo
    True

TESTS::

    sage: CFiniteSequence(x/(1-x))
    C-finite sequence, generated by x/(-x + 1)
    sage: r = CFiniteSequence.from_recurrence([-1],[1])
    sage: s = CFiniteSequence.from_recurrence([-1],[1,-1])
    sage: r == s
    True
    sage: r = CFiniteSequence(x^3/(1-x-x^2)).recurrence_repr()
    'Homogenous linear recurrence with constant coefficients of degree 2: a(n+2) = 1*a(n) + 1*a(n+1), starting a(3) = 1, a(4) = 1'
    sage: s = CFiniteSequence.from_recurrence([1,1],[0,0,0,1,1])
    sage: r == s
    True
    sage: r.seq(5)
    [0, 0, 0, 1, 1]
    sage: r.ogf()
    x^3/(-x^2 - x + 1)
    sage: CFiniteSequence(1/x)
    C-finite sequence, generated by x^-1
    sage: CFiniteSequence(1/(x^2-2*x^3))
    C-finite sequence, generated by x^-1 * 1/(-2*x + 1)
    'Homogenous linear recurrence with constant coefficients of degree 1: a(n+1) = 2*a(n), starting a(-1) = 1'

SEEALSO:
   :func:`fibonacci`, :class:`BinaryRecurrenceSequence`

AUTHORS:

    -Ralf Stephan (2014): initial version

REFERENCES
    .. [GK82] Greene, Daniel H.; Knuth, Donald E. (1982), "2.1.1 Constant coefficients – A) Homogeneous equations", Mathematics for the Analysis of Algorithms (2nd ed.), Birkhäuser, p. 17.
    .. [SZ94] Bruno Salvy and Paul Zimmermann. — Gfun: a Maple package for the manipulation of generating and holonomic functions in one variable. — Acm transactions on mathematical software, 20.2:163-177, 1994.
    .. [Z11] Zeilberger, Doron. "The C-finite ansatz." The Ramanujan Journal (2011): 1-10.
    
    """
#*****************************************************************************
#       Copyright (C) 2014 Ralf Stephan <gtrwst9@gmail.com>,
#
#  Distributed under the terms of the GNU General Public License (GPL) v2.0
#
#    This code is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#  The full text of the GPL is available at:
#
#                  http://www.gnu.org/licenses/gpl-2.0.html
#*****************************************************************************

from sage.rings.integer import Integer
from sage.rings.rational import Rational
from sage.rings.rational_field import QQ
from sage.rings.big_oh import O
from sage.rings.arith import gcd
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.polynomial.polynomial_ring import is_PolynomialRing
from sage.rings.polynomial.polynomial_element import Polynomial, is_Polynomial
from sage.rings.fraction_field_element import FractionFieldElement, is_FractionFieldElement
from sage.rings.laurent_series_ring import LaurentSeriesRing
from sage.rings.power_series_ring import PowerSeriesRing
from sage.rings.power_series_ring_element import PowerSeries

from sage.matrix.berlekamp_massey import berlekamp_massey
from sage.misc.prandom import randint

class CFiniteSequence(FractionFieldElement):

    def __init__(self, ogf, *args, **kwargs):

        """
    Create a C-finite sequence given its ordinary generating function.

    INPUT:

    - ``ogf`` -- the ordinary generating function, a fraction of polynomials


    OUTPUT:

    - A CFiniteSequence object

    EXAMPLES::

        sage: R.<x> = ZZ[]
        sage: CFiniteSequence((2-x)/(1-x-x^2))     # the Lucas sequence
        C-finite sequence, generated by (-x + 2)/(-x^2 - x + 1)
        sage: CFiniteSequence(x/(1-x)^3)           # triangular numbers
        C-finite sequence, generated by x/(-x^3 + 3*x^2 - 3*x + 1)
        sage: CFiniteSequence(x^2+3/x)
        x
        sage: CFiniteSequence(1/x+4/x^3)
        x
        sage: CFiniteSequence(1)
        Constant sequence a(0) = 1, a(n) = 0
        """

        self._off = 0
        self._deg = 0
        if is_FractionFieldElement(ogf):
            num = ogf.numerator()
            den = ogf.denominator()
            f = gcd(num, den)
            P = PolynomialRing(QQ, 'x')
            num = P(num / f)
            den = P(den / f)
            super(CFiniteSequence, self).__init__(P.fraction_field(), num, den, *args, **kwargs)

            if den.constant_coefficient() == 0:
                self._off = den.valuation()
            if den <> 1:
                self._deg = den.degree() - self._off

            R = LaurentSeriesRing(QQ, 'x')
            x = R.gen()
            alen = (max(self._deg, num.degree() + 1))
            R.set_default_prec (alen)
            p = R(num/den) / x ** self._off
            self._a = p.list()
            if len(self._a) < alen:
                self._a.extend([0] * (alen - len(self._a)))
            self._c = [-den.list()[i] for i in range(1, self._deg + 1)]
        elif ogf.parent().is_integral_domain():
            super(CFiniteSequence, self).__init__(ogf.parent().fraction_field(), ogf, 1, *args, **kwargs)
            self._c = []
            self._a = ogf.list()
        else:
            raise ValueError("Cannot convert a " + str(type(ogf)) + " to CFiniteSequence.")

    @classmethod
    def from_recurrence(cls, coefficients, values):
        """
    Create a C-finite sequence given the coefficients $c$ and starting values $a$
    of a homogenous linear recurrence.

    .. MATH::
    
        a_{n+d} = c_0a_n + c_1a_{n+1} + \cdots + c_{d-1}a_{n+d-1}, \quad d\ge0.

    INPUT:

    - ``coefficients`` -- a list of values

    - ``values`` -- start values, a list of values

    OUTPUT:

    - A CFiniteSequence object

    EXAMPLES::

        sage: CFiniteSequence.from_recurrence([1,1],[0,1])   # Fibonacci numbers
        C-finite sequence, generated by x/(-x^2 - x + 1)
        sage: CFiniteSequence.from_recurrence([-1,2],[0,1])    # natural numbers
        C-finite sequence, generated by x/(x^2 - 2*x + 1)
        """

        if not isinstance(coefficients, list):
            raise ValueError("Wrong type for recurrence coefficient list.")
        if not isinstance(values, list):
            raise ValueError("Wrong type for recurrence start value list.")
        deg = len(coefficients)

        co = coefficients[::-1]
        co.extend([0] * (len(values) - deg))
        R = PolynomialRing(QQ, 'x')
        x = R.gen()
        den = -1 + sum([x ** (n + 1) * co[n] for n in range(deg)])
        num = -values[0] + sum([x ** n * (-values[n] + sum([values[k] * co[n - 1 - k] for k in range(n)])) for n in range(1, len(values))])
        return cls(num / den)

    def __repr__(self):
        """
        Return textual definition of sequence.
        """

        if self._deg == 0:
            return 'Constant sequence a(0) = ' + str(self._ogf()) + ', a(n) = 0'
        else:
            return 'C-finite sequence, generated by ' + str(self.ogf())

    def coefficients(self):
        """
        Return the coefficients of the recurrence representation of the C-finite sequence.

        OUTPUT:

        - A list of values

        EXAMPLES::
        
            sage: R.<x>=ZZ[]
            sage: lucas = CFiniteSequence((2-x)/(1-x-x^2))        # the Lucas sequence
            sage: lucas.coefficients()
            [1, 1]
        """

        return self._c

    def recurrence_repr(self):
        """
        Return a string with the recurrence representation of the C-finite sequence.

        OUTPUT:

        - A CFiniteSequence object

        EXAMPLES::

            sage: R.<x> = ZZ[]
            sage: CFiniteSequence((2-x)/(1-x-x^2)).recurrence_repr()
            'Homogenous linear recurrence with constant coefficients of degree 2: a(n+2) = 1*a(n) + 1*a(n+1), starting a(0) = 2, a(1) = 1'
            sage: CFiniteSequence(x/(1-x)^3).recurrence_repr()
            'Homogenous linear recurrence with constant coefficients of degree 3: a(n+3) = 3*a(n) - 3*a(n+1) + 1*a(n+2), starting a(0) = 0, a(1) = 1, a(2) = 3'
            sage: CFiniteSequence(1).recurrence_repr()
            'Constant sequence a(0) = 1, a(n) = 0'
        """
        
        if self._deg == 0:
            return 'Constant sequence a(0) = ' + str(self._ogf()) + ', a(n) = 0'
        else:
            cstr = 'a(n+' + str(self._deg) + ') = ' + str(self._c[0]) + '*a(n)'
            for i in range(1, self._deg):
                if self._c[i] < 0:
                    cstr = cstr + ' - ' + str(-(self._c[i])) + '*a(n+' + str(i) + ')'
                elif self._c[i] > 0:
                    cstr = cstr + ' + ' + str(self._c[i]) + '*a(n+' + str(i) + ')'
                else:
                    cstr = cstr + ' + ' + str(self._c[i]) + '*a(n+' + str(i) + ')'
        astr = ', starting a(0) = ' + str(self._a[0])
        for i in range(1, len(self._a)):
            astr = astr + ', a(' + str(i) + ')' + ' = ' + str(self._a[i])
        return 'Homogenous linear recurrence with constant coefficients of degree ' + str(self._deg) + ': ' + cstr + astr

    def __eq__(self, other):
        """
    Compare two CFiniteSequences.

    EXAMPLES::

        sage: r = CFiniteSequence.from_recurrence([1,1],[2,1])
        sage: s = CFiniteSequence.from_recurrence([-1],[1])
        sage: r == s
        False
        sage: R.<x> = ZZ[]
        sage: r = CFiniteSequence.from_recurrence([-1],[1])
        sage: s = CFiniteSequence(1/(1+x))
        sage: r == s
        True
        """

        return self.ogf() == other.ogf()

    def __getitem__(self, key) :
        r"""
        Return a slice of the sequence.

        EXAMPLE::
        
            sage: r = CFiniteSequence.from_recurrence([3,3],[2,1])
            sage: r[2]
            9
            sage: r[101]
            16158686318788579168659644539538474790082623100896663971001
            sage: R.<x> = ZZ[]
            sage: r = CFiniteSequence(1/(1-x))
            sage: r[5]
            1
            sage: r = CFiniteSequence(x)
            sage: r[0]
            0
            sage: r[1]
            1
            sage: r = CFiniteSequence(0)
            sage: r[66]
            0
            sage: lucas = CFiniteSequence.from_recurrence([1,1],[2,1])
            sage: lucas[5:10]
            [11, 18, 29, 47, 76]
        """

        if isinstance(key, slice) :
            m = max(key.start, key.stop)
            return [self[ii] for ii in xrange(*key.indices(m + 1))]
        elif isinstance(key, (Integer, int)) :
            from sage.matrix.constructor import Matrix
            d = self._deg
            if key < 0 :  # Handle negative indices
                raise IndexError, "The index (%d) is out of range." % key
            if d == 0:
                if len(self._a) > key: return self._a[key]
                else:                  return 0
            A = Matrix(QQ, 1, d, self._c)
            B = Matrix.identity(QQ, d - 1)
            C = Matrix(QQ, d - 1, 1, 0)
            V = Matrix(QQ, d, 1, self._a[:d][::-1])
            M = Matrix.block([[A], [B, C]], subdivide=False)
            return list(M ** (key - 1) * V)[0][0]
        else:
            raise TypeError, "Invalid argument type."

    def ogf(self):
        """
        Return the ordinary generating function associated with the CFiniteSequence.
        This is always a polynomial fraction.

        EXAMPLES::
        
            sage: R = CFiniteSequence.from_recurrence([2],[1])   # powers of 2
            sage: R.ogf()
            1/(-2*x + 1)
        """

        return self.numerator() / self.denominator()

    def series(self, n):
        """
        Return the Laurent power series associated with the CFiniteSequence, with precision n.
        
        INPUT:

        - ``n`` -- a nonnegative integer

        EXAMPLES::

            sage: r = CFiniteSequence.from_recurrence([-1,2],[0,1])
            sage: r.series(5)
            x + 2*x^2 + 3*x^3 + 4*x^4 + O(x^5)
        """

        R = PowerSeriesRing(QQ, 'x')
        return R(self.numerator(), prec=n) / R(self.denominator(), prec=n)

    def seq(self, n):
        """
        Return the first n members of the sequence. The first term has index 0.
        
        INPUT:

        - ``n`` -- a nonnegative integer

        OUTPUT:

        - a list of values
        
        EXAMPLES::

            sage: r = CFiniteSequence.from_recurrence([-1,2],[0,1])
            sage: r.seq(5)
            [0, 1, 2, 3, 4]
        """

        if n <= len(self._a):
            outlist = self._a[:n]
        else:
            outlist = self._a
            R = PowerSeriesRing(QQ, 'x')
            fullseq = (R(self.numerator(), prec=n) / R(self.denominator(), prec=n)).padded_list(n)
            outlist.extend(fullseq[len(self._a):])
        return outlist

    @staticmethod
    def guess(sequence):
        """
        Return the minimal CFiniteSequence that generates the sequence. Assume the first
        value has index 0.

        INPUT:

        - ``sequence`` -- list of integers

        EXAMPLES::

            sage: CFiniteSequence.guess([1,2,4,8,16,32])
            C-finite sequence, generated by 1/(-2*x + 1)
        """
        
        R = PowerSeriesRing(QQ, 'x')
        S = PolynomialRing(QQ, 'x')
        if len(sequence) % 2 == 1: sequence = sequence[:-1]
        l = len(sequence) - 1
        denominator = S(berlekamp_massey(sequence).list()[::-1])
        numerator = R(S(sequence) * denominator, prec=l).truncate()

        return CFiniteSequence(numerator / denominator)

    @staticmethod
    def random_object():
        """
        Return random CFiniteSequence.
        
        EXAMPLES::

            sage: CFiniteSequence.random_object()   # random
            C-finite sequence, generated by (-5*x - 1)/(-2*x^2 - 24*x + 1)
        """
        
        deg = randint(1, 10)
        R = PolynomialRing(Integers(), 'x')
        x = R.gen()
        return CFiniteSequence(R.random_element(deg - 1) / (1 + x * R.random_element(deg)))

"""
        sage: r.egf()      # not implemented
        exp(2*x)

.. TODO::
        
        sage: CFiniteSequence(x+x^2+x^3+x^4+x^5+O(x^6))
        ... x/(1-x)
        sage: latex(r)        # not implemented
        \big\{a_{n\ge0}\big|a_{n+2}=\sum_{i=0}^{1}c_ia_{n+i}, c=\{1,1\}, a_{n<2}=\{0,0,0,1\}\big\}
        """
